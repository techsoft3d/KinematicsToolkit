var hcBspline;(()=>{"use strict";var e={d:(t,i)=>{for(var n in i)e.o(i,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:i[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{CubicBezierCurve:()=>h,CurveManager:()=>n,CurveSegments:()=>u,bsplineOperator:()=>i});class i{constructor(e){this._viewer=e,this._bounding=null,this._mouseDownSelection=null,this._mouseButton=null,this._partinfo=[],this._hovertimeout=null,this._mouseMoved=!1,this._foundcurve=null,this._foundnodeid=null,this._lockPlane=null,this._viewer.operatorManager.getOperator(Communicator.OperatorId.Handle).setHandleSize(.35)}setPlane(e){this._lockPlane=e}async onMouseDown(e){blockRightClick=!1,this._mouseMoved=!1,this._foundcurve=null,this._foundnodeid=null,n.mouseClickPosition=e.getPosition().copy(),this._mouseButton=e.getButton();let t=e.getPosition();var i=new Communicator.PickConfig(Communicator.SelectionMask.All),o=await n.viewer.view.pickFromPoint(t,i);if(o){let t=o.getNodeId();if(t){0==n.viewer.model.getNodeChildren(t).length&&(t=n.viewer.model.getNodeParent(t));let i=n.findByNodeId(t);i&&(this._foundnodeid=t,this._foundCurve=i,n.viewer.model.setInstanceModifier(Communicator.InstanceModifier.DoNotSelect,[t],!0),e.setHandled(!0))}}e.setHandled(!1)}needsSelection(e){return e===Communicator.EventType.MouseDown}async onMouseMove(e){if(blockRightClick=!0,this._mouseMoved=!0,this._foundCurve){if(e.shiftDown()){let o=e.getPosition();var t=new Communicator.PickConfig(Communicator.SelectionMask.All),i=await n.viewer.view.pickFromPoint(o,t);if(i){let e=i.getPosition(),t=new Communicator.Matrix;t.setTranslationComponent(e.x,e.y,e.z),await this._foundCurve.cseg.updateByNodeid([this._foundnodeid],[t]),await this._viewer.model.setNodeMatrix(this._foundnodeid,t)}}else{let t=this._viewer.model.getNodeMatrix(this._foundnodeid),i=new Communicator.Point3(t.m[12],t.m[13],t.m[14]),n=this._viewer.view.getCamera(),o=n.getPosition(),s=n.getTarget(),r=Communicator.Point3.subtract(s,o).normalize(),a=Communicator.Plane.createFromPointAndNormal(i,r),c=new Communicator.Point3,h=this._viewer.view.raycastFromPoint(e.getPosition()),l=null;if(l=this._lockPlane?this._lockPlane.intersectsRay(h,c):a.intersectsRay(h,c),l){let e=new Communicator.Matrix;e.setTranslationComponent(c.x,c.y,c.z),await this._foundCurve.cseg.updateByNodeid([this._foundnodeid],[e]),await this._viewer.model.setNodeMatrix(this._foundnodeid,e)}}e.setHandled(!0)}}async onMouseUp(e){if(this._foundCurve&&n.viewer.model.setInstanceModifier(Communicator.InstanceModifier.DoNotSelect,[this._foundnodeid],!1),!this._mouseMoved)if(e.shiftDown()){let o=e.getPosition();var t=new Communicator.PickConfig(Communicator.SelectionMask.All),i=await n.viewer.view.pickFromPoint(o,t);if(i){i.getPosition();let t=i.getNodeId();0==n.viewer.model.getNodeChildren(t).length&&(t=n.viewer.model.getNodeParent(t)),n.findByNodeId(t)&&(setTimeout((()=>{let e=this._viewer.operatorManager.getOperator(Communicator.OperatorId.Handle);e.addHandles([t]),e.setNodeIds([t]),e.showHandles()}),200),e.setHandled(!0))}}else this._foundnodeid&&this._viewer.selectionManager.selectNode(this._foundnodeid,e.controlDown()?Communicator.SelectionMode.Add:Communicator.SelectionMode.Set);this._foundCurve&&(e.setHandled(!0),this._foundCurve=null,n.viewer.model.setInstanceModifier(Communicator.InstanceModifier.DoNotSelect,[this._foundnodeid],!1))}}class n{static async initialize(e){n.viewer=e,n.curveSegments=[],n.mouseClickPosition=null,n._cubeMesh=await async function(e,t,i,n){var o;o=.01;var s=new Communicator.MeshData;s.setFaceWinding(Communicator.FaceWinding.Clockwise);var r=[-.01,o,o,o,o,o,-.01,-.01,o,o,o,o,o,-.01,o,-.01,-.01,o,o,o,-.01,-.01,o,-.01,-.01,-.01,-.01,o,o,-.01,-.01,-.01,-.01,o,-.01,-.01,-.01,o,-.01,o,o,-.01,o,o,o,-.01,o,-.01,o,o,o,-.01,o,o,-.01,-.01,-.01,o,-.01,o,o,-.01,-.01,-.01,-.01,-.01,-.01,-.01,o,o,-.01,o,-.01,o,-.01,-.01,o,o,-.01,-.01,-.01,-.01,o,o,-.01,-.01,o,-.01,-.01,-.01,o,o,o,o,o,-.01,o,-.01,-.01,o,o,o,o,-.01,-.01,o,-.01,o];return s.addFaces(r,[0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0]),await e.model.createMesh(s)}(e),e.selectionManager.setSelectionFilter((function(e){return n.viewer.model.getNodeType(e)===Communicator.NodeType.BodyInstance?n.viewer.model.getNodeParent(e):e})),n.viewer.setCallbacks({handleEvent:function(e,t,i,o){n.updateByNodeid(t,o)}}),n.setMainAxis(new Communicator.Point3(1,0,0),new Communicator.Point3(0,0,1))}static activateOperator(){n.splineOperator=new i(n.viewer),n.bsplineOperatorHandle=n.viewer.registerCustomOperator(n.splineOperator),n.viewer.operatorManager.push(n.bsplineOperatorHandle)}static add(e){n.curveSegments.push(e)}static findByNodeId(e){for(let t=0;t<n.curveSegments.length;t++){let i=n.curveSegments[t].findCurveByNodeId(e);if(i)return{cseg:n.curveSegments[t],info:i}}}static updateByNodeid(e,t){for(let i=0;i<n.curveSegments.length;i++)n.curveSegments[i].updateByNodeid(e,t)}static setMainAxis(e,t){n.upAxis=t,n.frontAxis=e,n.sideAxis=Communicator.Point3.cross(n.frontAxis,n.upAxis)}}class o{constructor(e,t){this.curve=e,this.nodeid=null,this._curvesegments=t,this._meshid=null,this._handlenode=null,this.isStart=!1,this.__v0handle=null,this.__v1handle=null,this.__v2handle=null,this.__v3handle=null}setStartCurve(e){this.isStart=e}async generate(){var e=new Communicator.MeshData;const t=this.curve.getPoints(50);let i=[];for(let e=0;e<t.length;e++)i.push(t[e].x),i.push(t[e].y),i.push(t[e].z);if(e.addPolyline(i),this._meshid)await n.viewer.model.replaceMesh(this._meshid,e);else{this._meshid=await n.viewer.model.createMesh(e);let t=new Communicator.MeshInstanceData(this._meshid);this.nodeid=n.viewer.model.createNode(this._curvesegments.nodeid),this._curvenodeid=await n.viewer.model.createMeshInstance(t,this.nodeid),n.viewer.model.setInstanceModifier(Communicator.InstanceModifier.DoNotSelect,[this._curvenodeid],!0)}this._curvesegments.hasHandles&&await this.generateHandles()}async generateHandles(){this._handlenode?(this.isStart?this._v0handle?await this._updateHandle(this._v0handle,this.curve.v0):this._v0handle=await this._createHandle(this.curve.v0,new Communicator.Color(0,0,255)):this._v0handle&&(await n.viewer.model.deleteNode(this._v0handle),this._v0handle=null),await this._updateHandle(this._v1handle,this.curve.v1),await this._updateHandle(this._v2handle,this.curve.v2),await this._updateHandle(this._v3handle,this.curve.v3)):(this._handlenode=await n.viewer.model.createNode(this.nodeid,"Handles"),this.isStart&&(this._v0handle=await this._createHandle(this.curve.v0,new Communicator.Color(0,0,255))),this._v1handle=await this._createHandle(this.curve.v1,new Communicator.Color(255,255,0)),this._v2handle=await this._createHandle(this.curve.v2,new Communicator.Color(255,255,0)),this._v3handle=await this._createHandle(this.curve.v3,new Communicator.Color(0,0,255))),await this._generateHandleLines()}async _generateHandleLines(){if(this._handlenode){var e=new Communicator.MeshData,t=new Communicator.MeshData;if(e.addPolyline([this.curve.v0.x,this.curve.v0.y,this.curve.v0.z,this.curve.v1.x,this.curve.v1.y,this.curve.v1.z]),t.addPolyline([this.curve.v2.x,this.curve.v2.y,this.curve.v2.z,this.curve.v3.x,this.curve.v3.y,this.curve.v3.z]),this._handlelinemesh1)await n.viewer.model.replaceMesh(this._handlelinemesh1,e),await n.viewer.model.replaceMesh(this._handlelinemesh2,t);else{this._handlelinemesh1=await n.viewer.model.createMesh(e),this._handlelinemesh2=await n.viewer.model.createMesh(t);let i=new Communicator.MeshInstanceData(this._handlelinemesh1),o=new Communicator.MeshInstanceData(this._handlelinemesh2),s=await n.viewer.model.createMeshInstance(i,this._handlenode),r=await n.viewer.model.createMeshInstance(o,this._handlenode);n.viewer.model.setInstanceModifier(Communicator.InstanceModifier.DoNotSelect,[s],!0),n.viewer.model.setInstanceModifier(Communicator.InstanceModifier.DoNotSelect,[r],!0),n.viewer.model.setNodesLineColor([this._handlenode],new Communicator.Color(128,128,255)),hwv.model.setNodesLinePattern([this._handlenode],[1,0],1,Communicator.LinePatternLengthUnit.Object)}}}async _createHandle(e,t){let i=new Communicator.MeshInstanceData(n._cubeMesh),o=n.viewer.model.createNode(this._handlenode),s=await n.viewer.model.createMeshInstance(i,o),r=new Communicator.Matrix;return r.setTranslationComponent(e.x,e.y,e.z),n.viewer.model.setNodeMatrix(o,r),n.viewer.model.setInstanceModifier(Communicator.InstanceModifier.SuppressCameraScale,[s],!0),n.viewer.model.setNodesFaceColor([s],t),o}async flushHandles(){await n.viewer.model.deleteNode(this._handlenode),this._handlenode=null,this._handlelinemesh1=null,this._handlelinemesh2=null,this.__v0handle=null,this.__v1handle=null,this.__v2handle=null,this.__v3handle=null}async flushAll(){await this.flushHandles(),await n.viewer.model.deleteNode(this.nodeid),this.nodeid=null,this._handlenode=null,this._handlelinemesh1=null,this._handlelinemesh2=null}async _updateHandle(e,t){let i=new Communicator.Matrix;i.setTranslationComponent(t.x,t.y,t.z),await n.viewer.model.setNodeMatrix(e,i)}updateControlPoints(e,t,i){this._v0handle==e?this.curve.v0.set(t.m[12],t.m[13],t.m[14]):this._v1handle==e?this.curve.v1.set(t.m[12],t.m[13],t.m[14]):this._v2handle==e?this.curve.v2.set(t.m[12],t.m[13],t.m[14]):this._v3handle==e&&this.curve.v3.set(t.m[12],t.m[13],t.m[14])}isNode(e){return this._v0handle==e?0:this._v1handle==e?1:this._v2handle==e?2:this._v3handle==e?3:-1}}function s(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}class r{constructor(){this.type="Curve",this.cacheArcLengths=null,this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const i=this.getUtoTmapping(e);return this.getPoint(i,t)}getPoints(e=5){const t=[];for(let i=0;i<=e;i++)t.push(this.getPoint(i/e));return t}getSpacedPoints(e=5){const t=[];for(let i=0;i<=e;i++)t.push(this.getPointAt(i/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let i,n=this.getPoint(0),o=0;t.push(0);for(let a=1;a<=e;a++)i=this.getPoint(a/e),o+=(s=i,r=n,Communicator.Point3.subtract(r,s).length()),t.push(o),n=i;var s,r;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const i=this.getLengths();let n=0;const o=i.length;let s;s=t||e*i[o-1];let r,a=0,c=o-1;for(;a<=c;)if(n=Math.floor(a+(c-a)/2),r=i[n]-s,r<0)a=n+1;else{if(!(r>0)){c=n;break}c=n-1}if(n=c,i[n]===s)return n/(o-1);const h=i[n];return(n+(s-h)/(i[n+1]-h))/(o-1)}getTangent(e,t){const i=1e-4;let n=e-i,o=e+i;n<0&&(n=0),o>1&&(o=1);const s=this.getPoint(n),r=this.getPoint(o),a=t||new Communicator.Point3;let c=r.subtract(s).normalize();return a.set(c.x,c.y,c.z),a}getTangentAt(e,t){const i=this.getUtoTmapping(e);return this.getTangent(i,t)}computeFrenetFrames(e,t){const i=new Communicator.Point3,n=[],o=[],r=[];let a=new Communicator.Point3,c=new Communicator.Matrix;for(let t=0;t<=e;t++){const i=t/e;n[t]=this.getTangentAt(i,new Communicator.Point3)}o[0]=new(new Communicator.Point3),r[0]=new(new Communicator.Point3);let h=Number.MAX_VALUE;const l=Math.abs(n[0].x),u=Math.abs(n[0].y),d=Math.abs(n[0].z);l<=h&&(h=l,i.set(1,0,0)),u<=h&&(h=u,i.set(0,1,0)),d<=h&&i.set(0,0,1),a=Communicator.Point3.cross(n[0],i),a.normalize(),o[0]=Communicator.Point3.cross(n[0],a),r[0]=Communicator.Point3.cross(n[0],o[0]);for(let t=1;t<=e;t++){if(o[t]=o[t-1].copy(),r[t]=r[t-1].copy(),a=Communicator.Point3.cross(n[t-1],n[t]),a.length()>Number.EPSILON){a.normalize();const e=Math.acos(s(Communicator.Point3.dot(n[t-1],n[t]),-1));c=Communcator.Matrix.createFromOffAxisRotation(a,e),c.transform(o[t],o[t])}r[t]=Communicator.Point3.cross(n[t],o[t])}if(!0===t){let t=Math.acos(s(Communicator.Point3.dot(o[0],o[e]),-1));t/=e,Communicator.Point3.dot(n[0],Communicator.Point3.cross(o[0],o[e]))>0&&(t=-t);for(let i=1;i<=e;i++)c=Communcator.Matrix.createFromOffAxisRotation(n[i],t*i),c.transform(o[i],o[i]),r[i]=Communicator.Point3.cross(n[i],o[i])}return{tangents:n,normals:o,binormals:r}}clone(){return(new this.constructor).copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJson(){const e={};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJson(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}function a(e,t,i,n,o){return function(e,t){const i=1-e;return i*i*i*t}(e,t)+function(e,t){const i=1-e;return 3*i*i*e*t}(e,i)+function(e,t){return 3*(1-e)*e*e*t}(e,n)+function(e,t){return e*e*e*t}(e,o)}function c(e,t){let i=Communicator.Point3.dot(e.normal,t)+e.d;return Communicator.Point3.subtract(t,new Communicator.Point3(i*e.normal.x,i*e.normal.y,i*e.normal.z))}class h extends r{constructor(e=new Communicator.Point3,t=new Communicator.Point3,i=new Communicator.Point3,n=new Communicator.Point3){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=i,this.v3=n}getPoint(e,t=new Communicator.Point3){const i=t,n=this.v0,o=this.v1,s=this.v2,r=this.v3;return i.set(a(e,n.x,o.x,s.x,r.x),a(e,n.y,o.y,s.y,r.y),a(e,n.z,o.z,s.z,r.z)),i}setLinear(){this.v1=this.v0.copy(),this.v2=this.v3.copy()}setCurve(e,t){let i=1;t&&(i=-1);let n=Communicator.Point3.subtract(this.v3,this.v0).length(),o=Communicator.Matrix.createFromOffAxisRotation(e,45*i),s=Communicator.Matrix.createFromOffAxisRotation(e,-45*i),r=Communicator.Point3.subtract(this.v3,this.v0).normalize();r.scale(n/2.5);let a=o.transform(r);this.v1=Communicator.Point3.add(this.v0,a);let c=Communicator.Point3.subtract(this.v0,this.v3).normalize();c.scale(n/2.5);let h=s.transform(c);this.v2=Communicator.Point3.add(this.v3,h)}alignToPlane(e){this.v0=c(e,this.v0),this.v1=c(e,this.v1),this.v2=c(e,this.v2),this.v3=c(e,this.v3)}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJson(){const e=super.toJson();return e.v0=this.v0.toJson(),e.v1=this.v1.toJson(),e.v2=this.v2.toJson(),e.v3=this.v3.toJson(),e}fromJson(e){return super.fromJson(e),this.v0=Communicator.Point3.fromJson(e.v0),this.v1=Communicator.Point3.fromJson(e.v1),this.v2=Communicator.Point3.fromJson(e.v2),this.v3=Communicator.Point3.fromJson(e.v3),this}}function l(e,t,i){return Math.atan2(Communicator.Point3.dot(Communicator.Point3.cross(e,t),i),Communicator.Point3.dot(e,t))*(180/Math.PI)}class u{constructor(){this.curves=[],this.nodeid=null,this.hasHandles=!0}async enableGeometry(){this.nodeid||(this.nodeid=await hwv.model.createNode(n.viewer.model.getRootNode(),"_curves")),await this.generate()}async setLinear(e){this.curves[e].curve.setLinear(),await this.generate()}async setCurve(e,t){let i=n.viewer.view.getCamera(),o=i.getPosition(),s=i.getTarget(),r=Communicator.Point3.subtract(s,o).normalize();this.curves[e].curve.setCurve(r,t),await this.generate()}async alignToCameraPlaneFromSelection(){let e,t=n.viewer.selectionManager.getLast().getNodeId(),i=this.findCurveByNodeId(t);i&&(i.segment>=this.curves.length&&(i.segment=this.curves.length-1,i.controlpoint=3),0==i.controlpoint?e=this.curves[i.segment].curve.v0:3==i.controlpoint&&(e=this.curves[i.segment].curve.v3));let o=n.viewer.view.getCamera(),s=o.getPosition(),r=o.getTarget(),a=Communicator.Point3.subtract(r,s).normalize(),c=Communicator.Plane.createFromPointAndNormal(e,a);this.alignToPlane(c),this._reconnectCurves(),await this.generate()}lockPlaneFromSelection(){let e,t=n.viewer.selectionManager.getLast().getNodeId(),i=this.findCurveByNodeId(t);i&&(i.segment>=this.curves.length&&(i.segment=this.curves.length-1,i.controlpoint=3),0==i.controlpoint?e=this.curves[i.segment].curve.v0:3==i.controlpoint&&(e=this.curves[i.segment].curve.v3));let o=n.viewer.view.getCamera(),s=o.getPosition(),r=o.getTarget(),a=Communicator.Point3.subtract(r,s).normalize(),c=Communicator.Plane.createFromPointAndNormal(e,a);n.splineOperator.setPlane(c)}alignToPlane(e){for(let t=0;t<this.curves.length;t++)this.curves[t].curve.alignToPlane(e)}async addCurve(e){this.curves.length>0&&(e.v0=this.curves[this.curves.length-1].curve.v3),this.curves.push({curve:e,curveViz:null}),await this.generate()}async insertCurve(e,t){t>=this.curves.length?await this.addCurve(e):(this.curves.splice(t,0,{curve:e,curveViz:null}),this._reconnectCurves(),await this.generate())}async deleteCurve(e){this.curves[e].curveViz&&await this.curves[e].curveViz.flushAll(),this.curves.splice(e,1),this._reconnectCurves(),await this.generate()}async updateByNodeid(e,t){for(let i=0;i<e.length;i++)for(let n=0;n<this.curves.length;n++)this.curves[n].curveViz.updateControlPoints(e[i],t[i],0==i);await this.generate()}_reconnectCurves(){for(let e=0;e<this.curves.length;e++)e>0&&(this.curves[e].curve.v0=this.curves[e-1].curve.v3)}async flushHandles(){for(let e=0;e<this.curves.length;e++)await this.curves[e].curveViz.flushHandles()}async generate(){if(this.nodeid)for(let e=0;e<this.curves.length;e++)this.curves[e].curveViz||(this.curves[e].curveViz=new o(this.curves[e].curve,this)),this.curves[e].curveViz.setStartCurve(0==e),await this.curves[e].curveViz.generate()}async generateHandles(){for(let e=0;e<this.curves.length;e++)await this.curves[e].curveViz.generateHandles()}findCurveByNodeId(e){for(let t=0;t<this.curves.length;t++){let i=this.curves[t].curveViz.isNode(e);if(-1!=i)return 3==i?{segment:t+1,controlpoint:0}:{segment:t,controlpoint:i}}}getTotalLength(){let e=0;for(let t=0;t<this.curves.length;t++)e+=this.curves[t].curve.getLength();return e}getPointAt(e,t){let i=0;for(let o=0;o<this.curves.length;o++){let s=this.curves[o].curve.getLength();if(e<=i+s){let r,a=(e-i)/s,c=this.curves[o].curve.getTangentAt(a),h=l(c,n.frontAxis,n.upAxis),u=l(c,n.frontAxis,n.sideAxis),d=this.curves[o].curve.getPointAt(a);if(t){let e=new Communicator.Matrix;e.setTranslationComponent(d.x,d.y,d.z);let t=Communicator.Matrix.createFromOffAxisRotation(n.upAxis,-h),i=Communicator.Matrix.createFromOffAxisRotation(n.sideAxis,-u),o=Communicator.Matrix.multiply(t,i);r=Communicator.Matrix.multiply(o,e)}return{point:d,tangent:c,rot:h,rot2:u,matrix:r}}i+=s}}async insertAtSelection(){var e=new Communicator.PickConfig(Communicator.SelectionMask.All);let t=(await n.viewer.view.pickFromPoint(n.mouseClickPosition,e)).getPosition();if(n.viewer.selectionManager.getLast()){let e=n.viewer.selectionManager.getLast().getNodeId(),i=this.findCurveByNodeId(e);if(i){let e,n=i.segment;if(n<this.curves.length&&n>0){let i=this.curves[n].curve,o=new Communicator.Point3((i.v0.x+i.v3.x)/2,(i.v0.y+i.v3.y)/2,(i.v0.z+i.v3.z)/2);o=t,e=new h(o,o.copy(),o.copy(),o.copy())}else if(0==n){let i=this.curves[0].curve,n=i.v0;n=t,e=new h(n.copy(),n.copy(),n.copy(),i.v0.copy())}else{let i=this.curves[this.curves.length-1].curve.v3;i=t,e=new h(i.copy(),i.copy(),i.copy(),i.copy())}await this.insertCurve(e,n)}}else{let e=new h(t,t.copy(),t.copy(),t.copy());this.addCurve(e)}}toJson(){let e=[];for(let t=0;t<this.curves.length;t++)e.push(this.curves[t].curve.toJson());return{curvearray:e}}async fromJson(e){for(let t=0;t<e.curvearray.length;t++){let i=new h;i.fromJson(e.curvearray[t]),this.addCurve(i)}}}hcBspline=t})();